<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/png" href="https://nexucore.github.io/minesweeper/assets/minesweeperLogo.png">
    <title>Minesweeper</title>
    <style>
        :root {
            --xp-gray: #c0c0c0;
            --xp-white: #ffffff;
            --xp-shadow: #808080;
            --sprite-url: url('https://minesweeperonline.com/sprite100.gif');
        }

        body {
            background-color: #008080;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: 'Tahoma', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            overflow: hidden;
        }

        #viewport {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        #game-scaler {
            position: absolute;
            cursor: grab;
            display: flex;
            justify-content: center;
            align-items: center;
            transform-origin: 0 0;
            will-change: transform;
        }

        #game-scaler:active {
            cursor: grabbing;
        }

        .game-window {
            background-color: var(--xp-gray);
            padding: 6px;
            border: 3px solid;
            border-color: var(--xp-white) var(--xp-shadow) var(--xp-shadow) var(--xp-white);
            display: inline-flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        .controls {
            margin-bottom: 10px;
            font-size: 11px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .header-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 7px;
            margin-bottom: 6px;
            border: 3px solid;
            border-color: var(--xp-shadow) var(--xp-white) var(--xp-white) var(--xp-shadow);
            box-sizing: border-box;
        }

        .lcd-display {
            background-color: black;
            display: flex;
            padding: 1px;
            border: 1px solid var(--xp-shadow);
        }

        .digit {
            width: 13px;
            height: 23px;
            background-image: var(--sprite-url);
            background-repeat: no-repeat;
        }

        .digit-0 { background-position: 0px 0px; }
        .digit-1 { background-position: -13px 0px; }
        .digit-2 { background-position: -26px 0px; }
        .digit-3 { background-position: -39px 0px; }
        .digit-4 { background-position: -52px 0px; }
        .digit-5 { background-position: -65px 0px; }
        .digit-6 { background-position: -78px 0px; }
        .digit-7 { background-position: -91px 0px; }
        .digit-8 { background-position: -104px 0px; }
        .digit-9 { background-position: -117px 0px; }
        .digit-minus { background-position: -130px 0px; }

        .smiley-btn {
            width: 26px;
            height: 26px;
            background-image: var(--sprite-url);
            background-repeat: no-repeat;
            cursor: pointer;
            border: none;
            padding: 0;
            outline: none;
        }

        .face-smile { background-position: 0px -55px; }
        .face-pressed { background-position: -26px -55px; }
        .face-ooh { background-position: -52px -55px; }
        .face-dead { background-position: -78px -55px; }
        .face-win { background-position: -104px -55px; }

        #grid {
            display: grid;
            border: 3px solid;
            border-color: var(--xp-shadow) var(--xp-white) var(--xp-white) var(--xp-shadow);
            background-color: var(--xp-shadow);
            margin: 0 auto;
            box-sizing: content-box;
        }

        .cell {
            width: 16px;
            height: 16px;
            background-image: var(--sprite-url);
            background-repeat: no-repeat;
        }

        .cell-blank { background-position: 0px -39px; }
        .cell-flag { background-position: -16px -39px; }
        .cell-mine-hit { background-position: -32px -39px; }
        .cell-mine-wrong { background-position: -48px -39px; }
        .cell-mine-revealed { background-position: -64px -39px; }
        .cell-question { background-position: -80px -39px; }

        .num-0 { background-position: 0px -23px; }
        .num-1 { background-position: -16px -23px; }
        .num-2 { background-position: -32px -23px; }
        .num-3 { background-position: -48px -23px; }
        .num-4 { background-position: -64px -23px; }
        .num-5 { background-position: -80px -23px; }
        .num-6 { background-position: -96px -23px; }
        .num-7 { background-position: -112px -23px; }
        .num-8 { background-position: -128px -23px; }
    </style>
</head>
<body>

<div id="viewport">
    <div id="game-scaler">
        <div class="game-window" id="main-window">
            <div class="controls">
                <div>
                    Difficulty: 
                    <select id="difficulty" onchange="setupBoard(true)">
                        <option value="easy">Beginner</option>
                        <option value="medium">Intermediate</option>
                        <option value="hard">Expert</option>
                    </select>
                </div>
            </div>

            <div class="header-panel" id="header-panel">
                <div class="lcd-display" id="mine-count-display">
                    <div class="digit"></div><div class="digit"></div><div class="digit"></div>
                </div>
                <button class="smiley-btn face-smile" id="reset-btn" onclick="setupBoard(false)"></button>
                <div class="lcd-display" id="timer-display">
                    <div class="digit"></div><div class="digit"></div><div class="digit"></div>
                </div>
            </div>

            <div id="grid"></div>
        </div>
    </div>
</div>

<script>
    const levels = {
        easy: { r: 9, c: 9, m: 10 },
        medium: { r: 16, c: 16, m: 40 },
        hard: { r: 16, c: 30, m: 99 }
    };

    const sfx = {
        win: new Audio('https://nexucore.github.io/minesweeper/assets/win.mp3'),
        bomb: new Audio('https://nexucore.github.io/minesweeper/assets/explode.mp3'),
        pop: new Audio('https://nexucore.github.io/minesweeper/assets/pop.mp3')
    };

    let gridArr = [];
    let mineKeys = new Set();
    let squaresOpened = 0;
    let flaggedKeys = new Set();
    let isGameOver = false;
    let clock = null;
    let timeElapsed = 0;
    let freshGame = true;
    let mood = 'smile';
    let squishedCells = [];
    
    // Zoom & Pan State
    let scale = 1;
    let posX = 0;
    let posY = 0;
    let startDist = 0;
    let startScale = 1;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let isDragging = false;
    let hasMovedSignificantly = false;

    // Mobile specific interaction
    let holdTimer = null;
    let wasLongTap = false;
    let touchStartTime = 0;
    let touchStartPos = { x: 0, y: 0 };

    const scaler = document.getElementById('game-scaler');
    const viewport = document.getElementById('viewport');

    function playSound(name) {
        const sound = sfx[name];
        if (sound) { sound.currentTime = 0; sound.play().catch(() => {}); }
    }

    function updateTransform() {
        scaler.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
    }

    function resetView() {
        const win = document.getElementById('main-window');
        const vW = viewport.clientWidth;
        const vH = viewport.clientHeight;
        const gW = win.offsetWidth;
        const gH = win.offsetHeight;

        scale = Math.min((vW - 40) / gW, (vH - 120) / gH);
        if (scale > 2.5) scale = 2.5;
        if (scale < 0.5) scale = 0.5;

        posX = (vW - gW * scale) / 2;
        posY = (vH - gH * scale) / 2;
        
        updateTransform();
    }

    // --- ZOOM AND PAN LOGIC ---
    viewport.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = -e.deltaY;
        const factor = 1.1;
        const zoom = delta > 0 ? factor : 1 / factor;
        const mouseX = (e.clientX - posX) / scale;
        const mouseY = (e.clientY - posY) / scale;

        scale = Math.max(0.1, Math.min(scale * zoom, 10));
        posX = e.clientX - mouseX * scale;
        posY = e.clientY - mouseY * scale;
        updateTransform();
    }, { passive: false });

    viewport.addEventListener('mousedown', (e) => {
        if (e.button === 1 || (e.button === 0 && e.target === viewport)) {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }
    });

    window.addEventListener('mousemove', (e) => {
        if (isDragging) {
            posX += e.clientX - lastMouseX;
            posY += e.clientY - lastMouseY;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            updateTransform();
        }
    });

    window.addEventListener('mouseup', () => isDragging = false);

    viewport.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            startDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
            startScale = scale;
        } else if (e.touches.length === 1) {
            isDragging = true;
            lastMouseX = e.touches[0].pageX;
            lastMouseY = e.touches[0].pageY;
            touchStartPos = { x: lastMouseX, y: lastMouseY };
            hasMovedSignificantly = false;
        }
    }, { passive: true });

    viewport.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
            const zoom = dist / startDist;
            const midX = (e.touches[0].pageX + e.touches[1].pageX) / 2;
            const midY = (e.touches[0].pageY + e.touches[1].pageY) / 2;
            const worldX = (midX - posX) / scale;
            const worldY = (midY - posY) / scale;

            scale = Math.max(0.1, Math.min(startScale * zoom, 10));
            posX = midX - worldX * scale;
            posY = midY - worldY * scale;
            updateTransform();
            hasMovedSignificantly = true;
        } else if (e.touches.length === 1 && isDragging) {
            const dx = e.touches[0].pageX - lastMouseX;
            const dy = e.touches[0].pageY - lastMouseY;
            if (Math.hypot(e.touches[0].pageX - touchStartPos.x, e.touches[0].pageY - touchStartPos.y) > 10) {
                hasMovedSignificantly = true;
            }
            posX += dx;
            posY += dy;
            lastMouseX = e.touches[0].pageX;
            lastMouseY = e.touches[0].pageY;
            updateTransform();
        }
    }, { passive: true });

    viewport.addEventListener('touchend', () => {
        isDragging = false;
        // Reset flags so the next interaction is clean
        setTimeout(() => {
        hasMovedSignificantly = false;
    }, 10);
    
    // Ensure the visual state returns to normal after moving the camera
    liftSquish();
    updateFace(mood);
});

    // --- GAME LOGIC ---

    /**
     * @param {boolean} shouldResetView - If true, re-centers and re-zooms the camera.
     */
    function setupBoard(shouldResetView = false) {
        const diff = document.getElementById('difficulty').value;
        let { r: rows, c: cols, m: mines } = levels[diff];
        
        if (window.innerHeight > window.innerWidth && diff === 'hard') {
            rows = 30; cols = 16;
        }

        const gridUI = document.getElementById('grid');
        const header = document.getElementById('header-panel');
        
        isGameOver = false; freshGame = true; squaresOpened = 0;
        mineKeys.clear(); flaggedKeys.clear();
        if (clock) clearInterval(clock);
        timeElapsed = 0; mood = 'smile'; squishedCells = [];
        
        updateFace('smile');
        drawLCD('timer-display', 0);
        drawLCD('mine-count-display', mines);

        gridUI.style.gridTemplateColumns = `repeat(${cols}, 16px)`;
        gridUI.style.width = `${cols * 16}px`;
        header.style.width = `${cols * 16 + 6}px`; 
        gridUI.innerHTML = '';
        gridArr = [];

        for (let y = 0; y < rows; y++) {
            gridArr[y] = [];
            for (let x = 0; x < cols; x++) {
                const el = document.createElement('div');
                el.className = 'cell cell-blank';
                
                el.addEventListener('mousedown', (e) => {
                    if (e.button === 0) handleInteractionStart(y, x);
                    if (e.button === 2) rightClick(y, x);
                });
                el.addEventListener('mouseup', (e) => {
                    if (e.button === 0) handleInteractionEnd(y, x);
                });

                el.addEventListener('touchstart', (e) => {
                    if (e.touches.length > 1) {
                        clearTimeout(holdTimer);
                        liftSquish();
                        return;
                    }
                    hasMovedSignificantly = false;
                    holdTimer = setTimeout(() => {
                        if (!hasMovedSignificantly) {
                            wasLongTap = true;
                            rightClick(y, x);
                            liftSquish();
                        }
                    }, 400);
                    handleInteractionStart(y, x);
                }, { passive: true });

                el.addEventListener('touchend', (e) => {
                    clearTimeout(holdTimer);
                    if (!wasLongTap && !hasMovedSignificantly) {
                        handleInteractionEnd(y, x);
                    }
                    wasLongTap = false;
                });

                el.addEventListener('contextmenu', e => e.preventDefault());

                gridUI.appendChild(el);
                gridArr[y][x] = { el, isMine: false, isRevealed: false, isFlagged: false, count: 0, y, x };
            }
        }
        
        // Only reset camera position if difficulty changed
        if (shouldResetView) {
            requestAnimationFrame(() => resetView());
        }
    }

    function handleInteractionStart(y, x) {
        if (isGameOver) return;
        updateFace('ooh');
        visualSquish(y, x);
    }

    function handleInteractionEnd(y, x) {
        if (isGameOver || hasMovedSignificantly) {
            liftSquish();
            updateFace(mood);
            return;
        }
        liftSquish();
        updateFace(mood);
        if (gridArr[y][x].isRevealed) tryChord(y, x);
        else leftClick(y, x);
    }

    function visualSquish(y, x) {
        liftSquish();
        const cell = gridArr[y][x];
        if (cell.isRevealed) {
            findNeighbors(y, x).forEach(n => {
                const target = gridArr[n.y][n.x];
                if (!target.isRevealed && !target.isFlagged) {
                    target.el.className = 'cell num-0';
                    squishedCells.push(target);
                }
            });
        } else if (!cell.isFlagged) {
            cell.el.className = 'cell num-0';
            squishedCells.push(cell);
        }
    }

    function liftSquish() {
        while (squishedCells.length > 0) {
            const cell = squishedCells.pop();
            if (!cell.isRevealed) {
                cell.el.className = cell.isFlagged ? 'cell cell-flag' : 'cell cell-blank';
            }
        }
    }

    function leftClick(y, x) {
        if (isGameOver || gridArr[y][x].isFlagged || gridArr[y][x].isRevealed) return;
        if (freshGame) { seedMines(y, x); tick(); freshGame = false; }
        if (gridArr[y][x].isMine) { boom(y, x); return; }
        playSound('pop');
        floodFill(y, x);
        checkWin();
    }

    function rightClick(y, x) {
        if (isGameOver || gridArr[y][x].isRevealed) return;
        const cell = gridArr[y][x];
        cell.isFlagged = !cell.isFlagged;
        cell.el.className = cell.isFlagged ? 'cell cell-flag' : 'cell cell-blank';
        if (cell.isFlagged) flaggedKeys.add(`${y},${x}`); else flaggedKeys.delete(`${y},${x}`);
        const diff = document.getElementById('difficulty').value;
        drawLCD('mine-count-display', levels[diff].m - flaggedKeys.size);
    }

    function tryChord(y, x) {
        const cell = gridArr[y][x];
        const neighbors = findNeighbors(y, x);
        const flags = neighbors.filter(n => gridArr[n.y][n.x].isFlagged).length;
        if (flags === cell.count) {
            neighbors.forEach(n => leftClick(n.y, n.x));
        }
    }

    function seedMines(safeY, safeX) {
        const diff = document.getElementById('difficulty').value;
        const { m: total } = levels[diff];
        const rows = gridArr.length, cols = gridArr[0].length;
        let count = 0;
        while (count < total) {
            let ry = Math.floor(Math.random() * rows), rx = Math.floor(Math.random() * cols);
            if (!gridArr[ry][rx].isMine && (Math.abs(ry - safeY) > 1 || Math.abs(rx - safeX) > 1)) {
                gridArr[ry][rx].isMine = true; mineKeys.add(`${ry},${rx}`); count++;
            }
        }
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                if (!gridArr[y][x].isMine) gridArr[y][x].count = findNeighbors(y, x).filter(n => gridArr[n.y][n.x].isMine).length;
            }
        }
    }

    function findNeighbors(y, x) {
        const rows = gridArr.length, cols = gridArr[0].length;
        const list = [];
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dy === 0 && dx === 0) continue;
                let ny = y + dy, nx = x + dx;
                if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) list.push({ y: ny, x: nx });
            }
        }
        return list;
    }

    function floodFill(y, x) {
        const cell = gridArr[y][x];
        if (cell.isRevealed || cell.isFlagged) return;
        cell.isRevealed = true; squaresOpened++;
        cell.el.className = `cell num-${cell.count}`;
        if (cell.count === 0) findNeighbors(y, x).forEach(n => floodFill(n.y, n.x));
    }

    function checkWin() {
        const total = gridArr.length * gridArr[0].length;
        const diff = document.getElementById('difficulty').value;
        if (squaresOpened === total - levels[diff].m) {
            isGameOver = true; clearInterval(clock); mood = 'win'; updateFace('win'); playSound('win');
            drawLCD('mine-count-display', 0);
        }
    }

    function boom(hitY, hitX) {
        isGameOver = true; clearInterval(clock); mood = 'dead'; updateFace('dead'); playSound('bomb');
        mineKeys.forEach(k => {
            const [y, x] = k.split(',').map(Number);
            if (!gridArr[y][x].isFlagged) gridArr[y][x].el.className = (y === hitY && x === hitX) ? 'cell cell-mine-hit' : 'cell cell-mine-revealed';
        });
        flaggedKeys.forEach(k => {
            const [y, x] = k.split(',').map(Number);
            if (!gridArr[y][x].isMine) gridArr[y][x].el.className = 'cell cell-mine-wrong';
        });
    }

    function drawLCD(id, val) {
        const digits = document.getElementById(id).querySelectorAll('.digit');
        let s = Math.abs(val).toString().padStart(3, '0');
        if (val < 0) s = '-' + Math.abs(val).toString().slice(-2).padStart(2, '0');
        if (val > 999) s = '999';
        s.split('').forEach((c, i) => {
            if (digits[i]) digits[i].className = 'digit ' + (c === '-' ? 'digit-minus' : `digit-${c}`);
        });
    }

    function updateFace(type) { document.getElementById('reset-btn').className = `smiley-btn face-${type}`; }
    function tick() {
        if (clock) clearInterval(clock);
        clock = setInterval(() => { timeElapsed = Math.min(timeElapsed + 1, 999); drawLCD('timer-display', timeElapsed); }, 1000);
    }

    window.addEventListener('resize', resetView);
    // Initial call: Reset the view on launch
    window.onload = () => setupBoard(true);
</script>
</body>
</html>
